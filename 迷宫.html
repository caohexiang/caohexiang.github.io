<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>迷宫挑战</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#3B82F6',
                        secondary: '#10B981',
                        danger: '#EF4444',
                        warning: '#F59E0B',
                        dark: '#1E293B',
                    },
                    fontFamily: {
                        sans: ['Inter', 'system-ui', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style type="text/tailwindcss">
        @layer utilities {
            .content-auto {
                content-visibility: auto;
            }
            .text-shadow {
                text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            }
            .animate-shake {
                animation: shake 0.5s;
                animation-iteration-count: infinite;
            }
            .animate-pulse-slow {
                animation: pulse 3s cubic-bezier(0.4, 0, 0.6, 1) infinite;
            }
            .animate-bounce-slow {
                animation: bounce 2s infinite;
            }
            .maze-wall {
                background: linear-gradient(135deg, #3B82F6 0%, #2563EB 100%);
                transition: all 0.3s ease;
                box-shadow: 0 2px 10px rgba(59, 130, 246, 0.3);
            }
            .maze-wall:hover {
                filter: brightness(1.1);
                box-shadow: 0 2px 15px rgba(59, 130, 246, 0.5);
            }
            .start-point {
                background: radial-gradient(circle, #10B981 0%, #059669 100%);
                transition: all 0.3s ease;
                box-shadow: 0 0 15px rgba(16, 185, 129, 0.7);
                cursor: pointer;
            }
            .start-point:hover {
                transform: scale(1.05);
                box-shadow: 0 0 20px rgba(16, 185, 129, 0.9);
            }
            .end-point {
                background: radial-gradient(circle, #F59E0B 0%, #D97706 100%);
                transition: all 0.3s ease;
                box-shadow: 0 0 15px rgba(245, 158, 11, 0.7);
            }
            .end-point:hover {
                transform: scale(1.05);
                box-shadow: 0 0 20px rgba(245, 158, 11, 0.9);
            }
            .player-cursor {
                position: absolute;
                width: 15px;
                height: 15px;
                background-color: rgba(255, 255, 255, 0.8);
                border-radius: 50%;
                pointer-events: none;
                box-shadow: 0 0 10px rgba(255, 255, 255, 0.7);
                z-index: 10;
                transition: all 0.1s ease-out;
            }
            .start-indicator {
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                color: white;
                font-weight: bold;
                text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
                pointer-events: none;
                z-index: 10;
                animation: pulse 2s infinite;
            }
            .modal-backdrop {
                backdrop-filter: blur(5px);
                background-color: rgba(0, 0, 0, 0.7);
            }
            @keyframes shake {
                0%, 100% { transform: translate(1px, 1px) rotate(0deg); }
                10%, 30%, 50%, 70%, 90% { transform: translate(-1px, -2px) rotate(-1deg); }
                20%, 40%, 60%, 80% { transform: translate(3px, 2px) rotate(1deg); }
            }
            @keyframes pulse {
                0%, 100% { opacity: 1; }
                50% { opacity: 0.7; }
            }
            @keyframes bounce {
                0%, 100% { transform: translateY(0); }
                50% { transform: translateY(-10px); }
            }
            @keyframes fadeIn {
                from { opacity: 0; transform: scale(0.9); }
                to { opacity: 1; transform: scale(1); }
            }
            .animate-fade-in {
                animation: fadeIn 0.3s ease-out forwards;
            }
        }
    </style>
</head>
<body class="bg-gradient-to-br from-gray-900 to-gray-800 min-h-screen flex flex-col items-center justify-center p-4 text-white">
    <!-- 游戏容器 -->
    <div id="game-container" class="max-w-4xl w-full mx-auto bg-dark/80 rounded-xl shadow-2xl p-6 backdrop-blur-md border border-gray-700">
        <!-- 游戏标题 -->
        <h1 class="text-[clamp(2rem,5vw,3rem)] font-bold text-center mb-6 text-transparent bg-clip-text bg-gradient-to-r from-primary to-secondary text-shadow">
            迷宫挑战
        </h1>
        
        <!-- 游戏说明 -->
        <div id="game-instructions" class="mb-8 bg-gray-800/50 rounded-lg p-4 border border-gray-700">
            <p class="text-lg mb-3 text-gray-300">
                <i class="fa fa-info-circle text-primary mr-2"></i>
                游戏目标：点击绿色旗帜开始，控制鼠标穿越迷宫到达终点，注意不要碰到墙壁！
            </p>
            <p class="text-lg mb-3 text-gray-300">
                <i class="fa fa-exclamation-triangle text-warning mr-2"></i>
                警告：如果碰到墙壁或成功完成游戏，将触发惊喜内容！
            </p>
            <button id="start-button" class="bg-primary hover:bg-primary/80 text-white font-bold py-2 px-6 rounded-full transition-all duration-300 transform hover:scale-105 hover:shadow-lg focus:outline-none focus:ring-2 focus:ring-primary/50">
                <i class="fa fa-play mr-2"></i>开始游戏
            </button>
        </div>
        
        <!-- 迷宫区域 -->
        <div id="maze-container" class="relative w-full aspect-[4/3] bg-gray-900 rounded-lg overflow-hidden border-2 border-gray-700 shadow-inner">
            <!-- 玩家光标 -->
            <div id="player-cursor" class="player-cursor hidden"></div>
            
            <!-- 迷宫将通过 JavaScript 动态生成 -->
        </div>
    </div>
    
    <!-- 恐怖内容容器 -->
    <div id="scare-container" class="fixed inset-0 bg-black z-50 hidden flex items-center justify-center">
        <div id="scare-content" class="relative">
            <img id="scare-image" src="" alt="恐怖图片" class="max-w-full max-h-screen">
            <audio id="scare-sound" preload="auto">
                <source src="https://assets.mixkit.co/sfx/preview/mixkit-scary-scream-1478.mp3" type="audio/mpeg">
            </audio>
        </div>
    </div>
    
    <!-- 游戏结束弹窗 -->
    <div id="game-modal" class="fixed inset-0 z-50 hidden items-center justify-center modal-backdrop">
        <div class="bg-dark/95 rounded-xl shadow-2xl p-8 max-w-md w-full mx-4 border border-gray-700 animate-fade-in">
            <h2 id="modal-title" class="text-2xl font-bold mb-4 text-primary text-center"></h2>
            <p id="modal-message" class="text-lg mb-6 text-gray-300 text-center"></p>
            <div class="flex justify-center space-x-4">
                <button id="modal-retry-button" class="bg-secondary hover:bg-secondary/80 text-white font-bold py-2 px-6 rounded-full transition-all duration-300 transform hover:scale-105 hover:shadow-lg focus:outline-none focus:ring-2 focus:ring-secondary/50">
                    <i class="fa fa-refresh mr-2"></i>再玩一次
                </button>
                <button id="modal-close-button" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-6 rounded-full transition-all duration-300 transform hover:scale-105 hover:shadow-lg focus:outline-none focus:ring-2 focus:ring-gray-500/50">
                    <i class="fa fa-times mr-2"></i>关闭
                </button>
            </div>
        </div>
    </div>

    <script>
        // 游戏配置
        const config = {
            cellSize: 25,
            wallThickness: 5,
            startX: 1,
            startY: 1,
            scareDuration: 3000, // 恐怖效果持续时间（毫秒）
            scareImages: [
                'https://www.sdword.com/uploads/allimg/20230702/2-230F2112410512.jpg'  // 替换为恐怖图片URL
            ],
            mazeDensity: 0.5, // 迷宫密度（0-1之间）
            animationDuration: 300, // 动画持续时间（毫秒）
            soundVolume: 0.8, // 音效音量
            mazeComplexity: 0.7, // 迷宫复杂度（0-1之间）
            maxDeadEnds: 10 // 最大死胡同数量
        };
        
        // 游戏状态
        let gameState = {
            isPlaying: false,
            isScaring: false,
            isGameStarted: false, // 标记游戏是否已开始（点击旗帜后）
            maze: [],
            player: { x: 0, y: 0 },
            walls: [],
            startPoint: null,
            endPoint: null,
            cellWidth: 0,
            cellHeight: 0
        };
        
        // DOM 元素
        const mazeContainer = document.getElementById('maze-container');
        const startButton = document.getElementById('start-button');
        const scareContainer = document.getElementById('scare-container');
        const scareImage = document.getElementById('scare-image');
        const scareSound = document.getElementById('scare-sound');
        const playerCursor = document.getElementById('player-cursor');
        const gameModal = document.getElementById('game-modal');
        const modalTitle = document.getElementById('modal-title');
        const modalMessage = document.getElementById('modal-message');
        const modalRetryButton = document.getElementById('modal-retry-button');
        const modalCloseButton = document.getElementById('modal-close-button');
        
        // 设置音效音量
        scareSound.volume = config.soundVolume;
        
        // 初始化事件监听
        function initEventListeners() {
            startButton.addEventListener('click', startGame);
            modalRetryButton.addEventListener('click', resetGame);
            modalCloseButton.addEventListener('click', closeModalAndReset);
            
            // 窗口调整大小时重新生成迷宫
            window.addEventListener('resize', () => {
                if (gameState.isPlaying) {
                    generateMaze();
                }
            });
        }
        
        // 开始游戏
        function startGame() {
            gameState.isPlaying = true;
            gameState.isGameStarted = false; // 游戏尚未真正开始（需要点击旗帜）
            startButton.classList.add('hidden');
            playerCursor.classList.remove('hidden');
            
            // 添加游戏开始动画
            mazeContainer.classList.add('animate-pulse-slow');
            
            // 播放开始音效
            const startSound = new Audio('https://assets.mixkit.co/sfx/preview/mixkit-arcade-game-start-2019.mp3');
            startSound.volume = 0.6;
            startSound.play();
            
            setTimeout(() => {
                mazeContainer.classList.remove('animate-pulse-slow');
                generateMaze();
                
                // 设置玩家初始位置在起点中心
                gameState.player.x = config.startX * gameState.cellWidth + gameState.cellWidth / 2;
                gameState.player.y = config.startY * gameState.cellHeight + gameState.cellHeight / 2;
                updatePlayerCursor();
                
                // 添加起点提示文字
                addStartIndicator();
            }, 1000);
        }
        
        // 添加起点提示文字
        function addStartIndicator() {
            const startIndicator = document.createElement('div');
            startIndicator.className = 'start-indicator';
            startIndicator.innerHTML = '<p class="text-xl mb-2">点击旗帜开始</p><i class="fa fa-arrow-down animate-bounce-slow"></i>';
            
            // 计算提示位置
            const startX = config.startX * gameState.cellWidth + gameState.cellWidth / 2;
            const startY = config.startY * gameState.cellHeight + gameState.cellHeight / 2 - 30; // 向上偏移
            
            startIndicator.style.left = `${startX}px`;
            startIndicator.style.top = `${startY}px`;
            
            mazeContainer.appendChild(startIndicator);
            
            // 为起点添加点击事件
            gameState.startPoint.addEventListener('click', handleStartClick);
        }
        
        // 处理起点点击事件
        function handleStartClick() {
            if (gameState.isGameStarted) return;
            
            gameState.isGameStarted = true;
            
            // 移除提示文字
            const startIndicator = document.querySelector('.start-indicator');
            if (startIndicator) {
                startIndicator.remove();
            }
            
            // 更改起点样式，使其不再可点击
            gameState.startPoint.classList.remove('cursor-pointer');
            gameState.startPoint.style.opacity = '0.7';
            
            // 添加点击开始的音效
            const clickSound = new Audio('https://assets.mixkit.co/sfx/preview/mixkit-arcade-game-jump-coin-216.mp3');
            clickSound.volume = 0.5;
            clickSound.play();
            
            // 添加鼠标移动事件监听
            mazeContainer.addEventListener('mousemove', handleMouseMove);
        }
        
        // 重置游戏
        function resetGame() {
            closeModal();
            gameState.isPlaying = true;
            gameState.isGameStarted = false;
            playerCursor.classList.remove('hidden');
            generateMaze();
            
            // 设置玩家初始位置在起点中心
            gameState.player.x = config.startX * gameState.cellWidth + gameState.cellWidth / 2;
            gameState.player.y = config.startY * gameState.cellHeight + gameState.cellHeight / 2;
            updatePlayerCursor();
            
            // 添加起点提示文字
            addStartIndicator();
        }
        
        // 关闭弹窗并重置到初始状态
        function closeModalAndReset() {
            closeModal();
            gameState.isPlaying = false;
            gameState.isGameStarted = false;
            playerCursor.classList.add('hidden');
            startButton.classList.remove('hidden');
            
            // 清空迷宫容器
            mazeContainer.innerHTML = '';
        }
        
        // 关闭弹窗
        function closeModal() {
            gameModal.classList.add('hidden');
            gameModal.classList.remove('flex');
        }
        
        // 显示弹窗
        function showModal(title, message) {
            modalTitle.textContent = title;
            modalMessage.textContent = message;
            gameModal.classList.remove('hidden');
            gameModal.classList.add('flex');
        }
        
        // 生成迷宫
        function generateMaze() {
            // 清空迷宫容器
            mazeContainer.innerHTML = '';
            mazeContainer.appendChild(playerCursor);
            
            // 计算迷宫的行数和列数
            const containerWidth = mazeContainer.clientWidth;
            const containerHeight = mazeContainer.clientHeight;
            const cols = Math.floor(containerWidth / config.cellSize);
            const rows = Math.floor(containerHeight / config.cellSize);
            
            // 保存单元格尺寸
            gameState.cellWidth = containerWidth / cols;
            gameState.cellHeight = containerHeight / rows;
            
            // 创建迷宫
            gameState.maze = createSimplerMaze(rows, cols);
            
            // 绘制迷宫
            drawMaze();
        }
        
        // 创建更简单、更通顺的迷宫
        function createSimplerMaze(rows, cols) {
            // 初始化迷宫（全是墙）
            const maze = Array(rows).fill().map(() => Array(cols).fill(1));
            
            // 随机选择起点（必须是奇数坐标）
            const startX = 1;
            const startY = 1;
            
            // 标记起点为通道
            maze[startY][startX] = 0;
            
            // 使用深度优先搜索算法生成主路径
            const stack = [{x: startX, y: startY}];
            
            // 可能的移动方向，优先选择直线路径
            const directions = [
                {dx: 0, dy: -2}, // 上
                {dx: 2, dy: 0},  // 右
                {dx: 0, dy: 2},  // 下
                {dx: -2, dy: 0}  // 左
            ];
            
            // 记录主路径
            const mainPath = [];
            
            while (stack.length > 0) {
                const current = stack[stack.length - 1];
                mainPath.push({x: current.x, y: current.y});
                const availableDirections = [];
                
                // 检查四个方向
                for (const dir of directions) {
                    const nx = current.x + dir.dx;
                    const ny = current.y + dir.dy;
                    
                    // 检查是否在边界内且未被访问
                    if (nx > 0 && nx < cols - 1 && ny > 0 && ny < rows - 1 && maze[ny][nx] === 1) {
                        availableDirections.push(dir);
                    }
                }
                
                if (availableDirections.length > 0) {
                    // 随机选择一个方向，但增加选择与上一步相同方向的概率
                    let randomDir;
                    if (stack.length > 1 && Math.random() < config.mazeComplexity) {
                        // 尝试继续当前方向
                        const lastDir = {
                            dx: current.x - stack[stack.length - 2].x,
                            dy: current.y - stack[stack.length - 2].y
                        };
                        
                        const sameDirection = availableDirections.find(dir => 
                            dir.dx === lastDir.dx && dir.dy === lastDir.dy
                        );
                        
                        if (sameDirection) {
                            randomDir = sameDirection;
                        } else {
                            randomDir = availableDirections[Math.floor(Math.random() * availableDirections.length)];
                        }
                    } else {
                        randomDir = availableDirections[Math.floor(Math.random() * availableDirections.length)];
                    }
                    
                    const nx = current.x + randomDir.dx;
                    const ny = current.y + randomDir.dy;
                    
                    // 打通墙壁
                    maze[ny][nx] = 0;
                    maze[current.y + randomDir.dy/2][current.x + randomDir.dx/2] = 0;
                    
                    // 将新单元格压入栈
                    stack.push({x: nx, y: ny});
                } else {
                    // 回溯
                    stack.pop();
                }
            }
            
            // 设置终点（选择主路径的最后一个点附近）
            const endPoint = mainPath[mainPath.length - 1];
            const endX = Math.min(endPoint.x, cols - 2);
            const endY = Math.min(endPoint.y, rows - 2);
            maze[endY][endX] = 0;
            
            // 创建一些死胡同，但限制数量
            let deadEnds = 0;
            for (let i = 0; i < mainPath.length && deadEnds < config.maxDeadEnds; i++) {
                const point = mainPath[i];
                
                // 随机决定是否在此点创建死胡同
                if (Math.random() > config.mazeDensity) {
                    const availableDirections = [];
                    
                    // 检查四个方向
                    for (const dir of directions) {
                        const nx = point.x + dir.dx;
                        const ny = point.y + dir.dy;
                        
                        // 检查是否在边界内且未被访问
                        if (nx > 0 && nx < cols - 1 && ny > 0 && ny < rows - 1 && maze[ny][nx] === 1) {
                            availableDirections.push(dir);
                        }
                    }
                    
                    // 随机选择一个方向创建死胡同
                    if (availableDirections.length > 0) {
                        const randomDir = availableDirections[Math.floor(Math.random() * availableDirections.length)];
                        const nx = point.x + randomDir.dx;
                        const ny = point.y + randomDir.dy;
                        
                        // 打通墙壁形成死胡同
                        maze[ny][nx] = 0;
                        maze[point.y + randomDir.dy/2][point.x + randomDir.dx/2] = 0;
                        
                        deadEnds++;
                    }
                }
            }
            
            return maze;
        }
        
        // 绘制迷宫
        function drawMaze() {
            // 清空墙列表
            gameState.walls = [];
            
            // 创建迷宫元素
            for (let y = 0; y < gameState.maze.length; y++) {
                for (let x = 0; x < gameState.maze[y].length; x++) {
                    if (gameState.maze[y][x] === 1) {
                        // 创建墙元素
                        const wall = document.createElement('div');
                        wall.className = 'maze-wall absolute';
                        wall.style.width = `${gameState.cellWidth}px`;
                        wall.style.height = `${gameState.cellHeight}px`;
                        wall.style.left = `${x * gameState.cellWidth}px`;
                        wall.style.top = `${y * gameState.cellHeight}px`;
                        wall.dataset.x = x;
                        wall.dataset.y = y;
                        
                        // 添加墙的出现动画
                        wall.style.opacity = '0';
                        wall.style.transform = 'scale(0.8)';
                        
                        mazeContainer.appendChild(wall);
                        gameState.walls.push(wall);
                        
                        // 延迟显示墙，创建动画效果
                        setTimeout(() => {
                            wall.style.opacity = '1';
                            wall.style.transform = 'scale(1)';
                            wall.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
                        }, x * 5 + y * 5);
                    }
                }
            }
            
            // 创建起点
            gameState.startPoint = document.createElement('div');
            gameState.startPoint.className = 'start-point absolute rounded-full';
            gameState.startPoint.style.width = `${gameState.cellWidth * 0.8}px`;
            gameState.startPoint.style.height = `${gameState.cellHeight * 0.8}px`;
            gameState.startPoint.style.left = `${config.startX * gameState.cellWidth + gameState.cellWidth * 0.1}px`;
            gameState.startPoint.style.top = `${config.startY * gameState.cellHeight + gameState.cellHeight * 0.1}px`;
            gameState.startPoint.innerHTML = '<i class="fa fa-flag text-white absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-xl"></i>';
            
            // 添加起点的出现动画
            gameState.startPoint.style.opacity = '0';
            gameState.startPoint.style.transform = 'scale(0.5)';
            
            mazeContainer.appendChild(gameState.startPoint);
            
            setTimeout(() => {
                gameState.startPoint.style.opacity = '1';
                gameState.startPoint.style.transform = 'scale(1)';
                gameState.startPoint.style.transition = 'opacity 0.5s ease, transform 0.5s ease';
            }, 500);
            
            // 创建终点
            const endX = gameState.maze[0].length - 2;
            const endY = gameState.maze.length - 2;
            
            gameState.endPoint = document.createElement('div');
            gameState.endPoint.className = 'end-point absolute rounded-full';
            gameState.endPoint.style.width = `${gameState.cellWidth * 0.8}px`;
            gameState.endPoint.style.height = `${gameState.cellHeight * 0.8}px`;
            gameState.endPoint.style.left = `${endX * gameState.cellWidth + gameState.cellWidth * 0.1}px`;
            gameState.endPoint.style.top = `${endY * gameState.cellHeight + gameState.cellHeight * 0.1}px`;
            gameState.endPoint.innerHTML = '<i class="fa fa-trophy text-white absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-xl"></i>';
            
            // 添加终点的出现动画
            gameState.endPoint.style.opacity = '0';
            gameState.endPoint.style.transform = 'scale(0.5)';
            
            mazeContainer.appendChild(gameState.endPoint);
            
            setTimeout(() => {
                gameState.endPoint.style.opacity = '1';
                gameState.endPoint.style.transform = 'scale(1)';
                gameState.endPoint.style.transition = 'opacity 0.5s ease, transform 0.5s ease';
            }, 1000);
        }
        
        // 更新玩家光标位置
        function updatePlayerCursor() {
            playerCursor.style.left = `${gameState.player.x - 7.5}px`;
            playerCursor.style.top = `${gameState.player.y - 7.5}px`;
        }
        
        // 处理鼠标移动
        function handleMouseMove(e) {
            if (!gameState.isPlaying || !gameState.isGameStarted || gameState.isScaring) return;
            
            // 获取鼠标在迷宫容器内的位置
            const rect = mazeContainer.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            // 更新玩家位置
            gameState.player.x = mouseX;
            gameState.player.y = mouseY;
            
            // 更新玩家光标
            updatePlayerCursor();
            
            // 检查是否碰到墙壁
            if (checkCollision(mouseX, mouseY)) {
                handleCollision();
                return;
            }
            
            // 检查是否到达终点
            if (checkWin(mouseX, mouseY)) {
                handleWin();
                return;
            }
        }
        
        // 检查碰撞
        function checkCollision(x, y) {
            // 检查是否碰到墙壁
            for (const wall of gameState.walls) {
                const wallX = parseFloat(wall.style.left);
                const wallY = parseFloat(wall.style.top);
                const wallWidth = parseFloat(wall.style.width);
                const wallHeight = parseFloat(wall.style.height);
                
                // 简化的碰撞检测
                if (x > wallX && x < wallX + wallWidth && y > wallY && y < wallY + wallHeight) {
                    return true;
                }
            }
            
            return false;
        }
        
        // 检查胜利条件
        function checkWin(x, y) {
            // 检查是否到达终点
            const endX = parseFloat(gameState.endPoint.style.left);
            const endY = parseFloat(gameState.endPoint.style.top);
            const endWidth = parseFloat(gameState.endPoint.style.width);
            const endHeight = parseFloat(gameState.endPoint.style.height);
            
            return x > endX && x < endX + endWidth && y > endY && y < endY + endHeight;
        }
        
        // 处理碰撞
        function handleCollision() {
            // 添加碰撞动画效果
            mazeContainer.classList.add('animate-shake');
            playerCursor.style.backgroundColor = 'rgba(239, 68, 68, 0.8)';
            
            // 播放碰撞音效
            const collisionSound = new Audio('https://assets.mixkit.co/sfx/preview/mixkit-arcade-game-jump-coin-216.mp3');
            collisionSound.volume = 0.5;
            collisionSound.play();
            
            setTimeout(() => {
                mazeContainer.classList.remove('animate-shake');
                playerCursor.style.backgroundColor = 'rgba(255, 255, 255, 0.8)';
                
                // 直接触发恐怖效果
                triggerScare();
            }, 500);
        }
        
        // 处理胜利
        function handleWin() {
            // 播放胜利音效
            const winSound = new Audio('https://assets.mixkit.co/sfx/preview/mixkit-winning-chimes-2015.mp3');
            winSound.volume = 0.6;
            winSound.play();
            
            // 添加胜利动画
            gameState.endPoint.style.animation = 'pulse 1s infinite';
            
            // 延迟触发恐怖效果
            setTimeout(() => {
                triggerScare();
            }, 1000);
        }
        
        // 触发恐怖效果
        function triggerScare() {
            gameState.isScaring = true;
            playerCursor.classList.add('hidden');
            
            // 随机选择一张恐怖图片
            const randomImage = config.scareImages[Math.floor(Math.random() * config.scareImages.length)];
            scareImage.src = randomImage;
            
            // 添加屏幕抖动效果
            document.body.classList.add('animate-shake');
            
            // 显示恐怖内容
            scareContainer.classList.remove('hidden');
            
            // 播放恐怖音效
            scareSound.currentTime = 0;
            scareSound.play().catch(e => console.error('无法播放音效:', e));
            
            // 3秒后隐藏恐怖内容
            setTimeout(() => {
                scareContainer.classList.add('hidden');
                document.body.classList.remove('animate-shake');
                gameState.isScaring = false;
                
                // 显示游戏结束弹窗
                showModal('挑战结束', '想再试一次吗？');
            }, config.scareDuration);
        }
        
        // 初始化游戏
        function initGame() {
            initEventListeners();
        }
        
        // 页面加载完成后初始化游戏
        window.addEventListener('DOMContentLoaded', initGame);
    </script>
</body>
</html>